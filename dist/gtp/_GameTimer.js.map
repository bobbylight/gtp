{"version":3,"sources":["gtp/_GameTimer.ts"],"names":["gtp","gtp._GameTimer","gtp._GameTimer.constructor","gtp._GameTimer.paused","gtp._GameTimer.playTime","gtp._GameTimer.updating","gtp._GameTimer.resetPlayTime","gtp._GameTimer.start"],"mappings":"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","file":"gtp/_GameTimer.js","sourcesContent":["module gtp {\n  'use strict';\n\n  /**\n   * This class keeps track of game time.  That includes both total running\n   * time, and \"active time\" (time not spent on paused screens, etc.).\n   * @constructor\n   */\n  export class _GameTimer {\n\n    private _startShift: number;\n    private _paused: boolean;\n    private _pauseStart: number;\n    private _updating: boolean;\n    private _notUpdatingStart: number;\n\n    constructor() {\n      this._paused = false;\n      this._pauseStart = 0;\n      this._updating = true;\n      this._notUpdatingStart = 0;\n    }\n\n    /**\n     * Returns whether this game is paused.\n     * @return {boolean} Whether this game is paused.\n     */\n    get paused(): boolean {\n      return this._paused;\n    }\n\n    /**\n     * Returns the length of time the game has been played so far.  This is\n     * \"playable time;\" that is, time in which the user is playing, and the\n     * game is not paused or in a \"not updating\" state (such as the main\n     * frame not having focus).\n     *\n     * @return {number} The amount of time the game has been played, in\n     *         milliseconds.\n     * @see resetPlayTime\n     */\n    get playTime(): number {\n      if (this._pauseStart !== 0) {\n      \treturn this._pauseStart - this._startShift;\n      }\n      else if (this._notUpdatingStart !== 0) {\n      \treturn this._notUpdatingStart - this._startShift;\n      }\n      return Utils.timestamp() - this._startShift;\n    }\n\n    /**\n     * Returns whether this game is updating itself each frame.\n     *\n     * @return {boolean} Whether this game is updating itself.\n     */\n    get updating(): boolean {\n      return this._updating;\n    }\n\n    /**\n     * Resets the \"playtime in milliseconds\" timer back to <code>0</code>.\n     *\n     * @see playTime\n     */\n    resetPlayTime() {\n      if (this.paused || !this.updating) {\n        throw 'Cannot reset playtime millis when paused or not updating';\n      }\n      this._startShift = Utils.timestamp();\n    }\n\n    /**\n     * Sets whether the game is paused.  The game is still told to handle\n     * input, update itself and render.  This is simply a flag that should\n     * be set whenever a \"pause\" screen is displayed.  It stops the \"in-game\n     * timer\" until the game is unpaused.\n     *\n     * @param paused Whether the game should be paused.\n     * @see setUpdating\n     */\n    set paused(paused: boolean) {\n      // Cannot pause while !updating, so this is okay\n      if (this._paused !== paused) {\n        this._paused = paused;\n        if (paused) {\n          this._pauseStart = Utils.timestamp();\n        }\n        else {\n          var pauseTime: number = Utils.timestamp() - this._pauseStart;\n          this._startShift += pauseTime;\n          this._pauseStart = 0;\n        }\n      }\n    }\n\n    /**\n     * Sets whether the game should be \"updating\" itself.  If a game is not\n     * \"updating\" itself, then it is effectively \"paused,\" and will not accept\n     * any input from the user.<p>\n     *\n     * This method can be used to temporarily \"pause\" a game when the game\n     * window loses focus, for example.\n     *\n     * @param updating {boolean} Whether the game should be updating itself.\n     */\n    set updating(updating: boolean) {\n      if (this._updating !== updating) {\n      \tthis._updating = updating;\n      \tif (!this.paused) { // \"pause\" state \"encompasses\" update state.\n      \t\tif (!this._updating) {\n      \t\t\tthis._notUpdatingStart = Utils.timestamp();\n      \t\t}\n      \t\telse {\n      \t\t\tvar notUpdatingTime: number = Utils.timestamp() - this._notUpdatingStart;\n      \t\t\tthis._startShift += notUpdatingTime;\n      \t\t\tthis._notUpdatingStart = 0;\n      \t\t}\n      \t}\n      }\n    }\n\n    /**\n     * Resets this timer.  This should be called when a new game is started.\n     */\n    start() {\n      this._startShift = Utils.timestamp();\n    }\n\n  }\n}\n"],"sourceRoot":"/source/"}