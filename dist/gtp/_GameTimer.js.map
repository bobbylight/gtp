{"version":3,"sources":["gtp/_GameTimer.ts"],"names":["gtp","gtp._GameTimer","gtp._GameTimer.constructor","gtp._GameTimer.paused","gtp._GameTimer.playTime","gtp._GameTimer.updating","gtp._GameTimer.resetPlayTime","gtp._GameTimer.start"],"mappings":"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","file":"gtp/_GameTimer.js","sourcesContent":["module gtp {\n\t'use strict';\n\n\t/**\n\t * This class keeps track of game time.  That includes both total running\n\t * time, and \"active time\" (time not spent on paused screens, etc.).\n\t * @constructor\n\t */\n\texport class _GameTimer {\n\n\t\tprivate _startShift: number;\n\t\tprivate _paused: boolean;\n\t\tprivate _pauseStart: number;\n\t\tprivate _updating: boolean;\n\t\tprivate _notUpdatingStart: number;\n\n\t\tconstructor() {\n\t\t\tthis._paused = false;\n\t\t\tthis._pauseStart = 0;\n\t\t\tthis._updating = true;\n\t\t\tthis._notUpdatingStart = 0;\n\t\t}\n\n\t\t/**\n\t\t * Returns whether this game is paused.\n\t\t * @return {boolean} Whether this game is paused.\n\t\t */\n\t\tget paused(): boolean {\n\t\t\treturn this._paused;\n\t\t}\n\n\t\t/**\n\t\t * Returns the length of time the game has been played so far.  This is\n\t\t * \"playable time;\" that is, time in which the user is playing, and the\n\t\t * game is not paused or in a \"not updating\" state (such as the main\n\t\t * frame not having focus).\n\t\t *\n\t\t * @return {number} The amount of time the game has been played, in\n\t\t *         milliseconds.\n\t\t * @see resetPlayTime\n\t\t */\n\t\tget playTime(): number {\n\t\t\tif (this._pauseStart !== 0) {\n\t\t\t\treturn this._pauseStart - this._startShift;\n\t\t\t}\n\t\t\telse if (this._notUpdatingStart !== 0) {\n\t\t\t\treturn this._notUpdatingStart - this._startShift;\n\t\t\t}\n\t\t\treturn Utils.timestamp() - this._startShift;\n\t\t}\n\n\t\t/**\n\t\t * Returns whether this game is updating itself each frame.\n\t\t *\n\t\t * @return {boolean} Whether this game is updating itself.\n\t\t */\n\t\tget updating(): boolean {\n\t\t\treturn this._updating;\n\t\t}\n\n\t\t/**\n\t\t * Resets the \"playtime in milliseconds\" timer back to <code>0</code>.\n\t\t *\n\t\t * @see playTime\n\t\t */\n\t\tresetPlayTime() {\n\t\t\tif (this.paused || !this.updating) {\n\t\t\t\tthrow 'Cannot reset playtime millis when paused or not updating';\n\t\t\t}\n\t\t\tthis._startShift = Utils.timestamp();\n\t\t}\n\n\t\t/**\n\t\t * Sets whether the game is paused.  The game is still told to handle\n\t\t * input, update itself and render.  This is simply a flag that should\n\t\t * be set whenever a \"pause\" screen is displayed.  It stops the \"in-game\n\t\t * timer\" until the game is unpaused.\n\t\t *\n\t\t * @param paused Whether the game should be paused.\n\t\t * @see setUpdating\n\t\t */\n\t\tset paused(paused: boolean) {\n\t\t\t// Cannot pause while !updating, so this is okay\n\t\t\tif (this._paused !== paused) {\n\t\t\t\tthis._paused = paused;\n\t\t\t\tif (paused) {\n\t\t\t\t\tthis._pauseStart = Utils.timestamp();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar pauseTime: number = Utils.timestamp() - this._pauseStart;\n\t\t\t\t\tthis._startShift += pauseTime;\n\t\t\t\t\tthis._pauseStart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Sets whether the game should be \"updating\" itself.  If a game is not\n\t\t * \"updating\" itself, then it is effectively \"paused,\" and will not accept\n\t\t * any input from the user.<p>\n\t\t *\n\t\t * This method can be used to temporarily \"pause\" a game when the game\n\t\t * window loses focus, for example.\n\t\t *\n\t\t * @param updating {boolean} Whether the game should be updating itself.\n\t\t */\n\t\tset updating(updating: boolean) {\n\t\t\tif (this._updating !== updating) {\n\t\t\t\tthis._updating = updating;\n\t\t\t\tif (!this.paused) { // \"pause\" state \"encompasses\" update state.\n\t\t\t\t\tif (!this._updating) {\n\t\t\t\t\t\tthis._notUpdatingStart = Utils.timestamp();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar notUpdatingTime: number = Utils.timestamp() - this._notUpdatingStart;\n\t\t\t\t\t\tthis._startShift += notUpdatingTime;\n\t\t\t\t\t\tthis._notUpdatingStart = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Resets this timer.  This should be called when a new game is started.\n\t\t */\n\t\tstart() {\n\t\t\tthis._startShift = Utils.timestamp();\n\t\t}\n\n\t}\n}\n"],"sourceRoot":"/source/"}