{"version":3,"sources":["../src/gtp/Delay.ts"],"names":[],"mappings":"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","file":"Delay.js","sourcesContent":["module gtp {\r\n\t'use strict';\r\n\r\n\t/**\r\n\t * Arguments to the Delay constructor.\r\n\t */\r\n\texport interface DelayArgs {\r\n\t\tmillis: any;\r\n\t\tminDelta?: number;\r\n\t\tmaxDelta?: number;\r\n\t\tcallback?: Function;\r\n\t\tloop?: boolean;\r\n\t\tloopCount?: number;\r\n\t}\r\n\r\n\t/**\r\n\t * A way to keep track of a delay.  Useful when you want some event to occur\r\n\t * every X milliseconds, for example.\r\n\t *\r\n\t * @param {object} args Arguments to this delay.\r\n\t * @param {number-or-array} args.millis The number of milliseconds between\r\n\t *        events.  You can specify an array of numbers to have the even trigger\r\n\t *        at non-equal intervals.\r\n\t * @param {int} [args.minDelta] If specified, a minimum amount of variance for\r\n\t *        the event.  May be negative, but should be larger than the smallest\r\n\t *        value specified in millis.\r\n\t * @param {int} [args.maxDelta] If specified, a maximum amount of variance for\r\n\t *        the event.\r\n\t * @param {int} [args.loop] If specified and <code>true</code>, this timer will\r\n\t *        automatically repeat and <code>isDone()</code> will never return\r\n\t *        <code>true</code>.\r\n\t * @param {int} [args.loopCount] This argument is only honored if\r\n\t *        <code>args.loop</code> is defined and <code>true</code>.  If true,\r\n\t *        this argument is the number of times to loop; if this argument is not\r\n\t *        specified, looping will occur indefinitely.\r\n\t * @param {function} [args.callback] If specified, a callback function that\r\n\t *        will be called when this delay fires.\r\n\t * @constructor\r\n\t */\r\n\texport class Delay {\r\n\r\n\t\t_initial: number[];\r\n\t\t_initialIndex: number;\r\n\t\t_callback: Function;\r\n\t\t_loop: boolean;\r\n\t\t_loopCount: number;\r\n\t\t_maxLoopCount: number;\r\n\t\t_minDelta: number;\r\n\t\t_maxDelta: number;\r\n\t\t_remaining: number;\r\n\t\t_curInitial: number;\r\n\r\n\t\tconstructor(args: DelayArgs) {\r\n\t\t\tif (!args || !args.millis) {\r\n\t\t\t\tthrow 'Missing required \"millis\" argument to gtp.Delay';\r\n\t\t\t}\r\n\t\t\tthis._initial = args.millis.length ? args.millis : [args.millis];\r\n\t\t\tthis._initialIndex = 0;\r\n\t\t\tif (args.minDelta && args.maxDelta) {\r\n\t\t\t\tthis.setRandomDelta(args.minDelta, args.maxDelta);\r\n\t\t\t}\r\n\t\t\tthis._callback = args.callback;\r\n\t\t\tthis._loop = !!args.loop;\r\n\t\t\tthis._loopCount = 0;\r\n\t\t\tthis._maxLoopCount = this._loop ? (args.loopCount || -1) : -1;\r\n\t\t\tthis.reset();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Should be called in the update() method of the current game state to\r\n\t\t * update this Delay.\r\n\t\t *\r\n\t\t * @param {int} delta The time that has elapsed since the last call to this\r\n\t\t *        method.\r\n\t\t */\r\n\t\tupdate(delta: number) {\r\n\t\t\tif (this._remaining > 0) {\r\n\t\t\t\tthis._remaining -= delta;\r\n\t\t\t\tif (this._remaining <= 0 && this._callback) {\r\n\t\t\t\t\tthis._callback(this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this._remaining <= 0) {\r\n\t\t\t\tif (this._loop) {\r\n\t\t\t\t\tif (this._maxLoopCount === -1 || this._loopCount < this._maxLoopCount - 1) {\r\n\t\t\t\t\t\tthis._loopCount++;\r\n\t\t\t\t\t\tthis.reset(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis._loopCount = this._maxLoopCount;\r\n\t\t\t\t\t\tthis._remaining = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._remaining = Math.max(0, this._remaining);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this.isDone();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the number of times this Delay has looped.\r\n\t\t *\r\n\t\t * @return {int} The number of times this Delay has looped.\r\n\t\t */\r\n\t\tgetLoopCount(): number {\r\n\t\t\treturn this._loopCount;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the maximum delta value, or -1 if none was defined.\r\n\t\t *\r\n\t\t * @return {int} The maximum delta value.\r\n\t\t * @see getMinDelta()\r\n\t\t */\r\n\t\tgetMaxDelta(): number {\r\n\t\t\treturn typeof this._maxDelta !== 'undefined' ? this._maxDelta : -1;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the minimum delta value, or -1 if none was defined.\r\n\t\t *\r\n\t\t * @return {int} The minimum delta value.\r\n\t\t * @see getMaxDelta()\r\n\t\t */\r\n\t\tgetMinDelta(): number {\r\n\t\t\treturn typeof this._minDelta !== 'undefined' ? this._minDelta : -1;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the remaining time on this delay.\r\n\t\t *\r\n\t\t * @return {int} The remaining time on this delay.\r\n\t\t */\r\n\t\tgetRemaining(): number {\r\n\t\t\treturn this._remaining;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns how far along we are in this delay, in the range\r\n\t\t * 0 - 1.\r\n\t\t *\r\n\t\t * @return {int} How far along we are in this delay.\r\n\t\t */\r\n\t\tgetRemainingPercent(): number {\r\n\t\t\treturn this._remaining / this._curInitial;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether this Delay has completed.\r\n\t\t *\r\n\t\t * @return {boolean} Whether this Delay has completed.\r\n\t\t */\r\n\t\tisDone(): boolean {\r\n\t\t\treturn (!this._loop || this._loopCount === this._maxLoopCount) &&\r\n\t\t\t\tthis._remaining <= 0;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Causes this delay to trigger with a little random variance.\r\n\t\t *\r\n\t\t * @param {int} min The minimum possible variance, inclusive.\r\n\t\t * @param {int} max The maximum possible variance, exclusive.\r\n\t\t */\r\n\t\tsetRandomDelta(min: number, max: number) {\r\n\t\t\tthis._minDelta = min;\r\n\t\t\tthis._maxDelta = max;\r\n\t\t}\r\n\r\n\t\treset(smooth?: boolean) {\r\n\t\t\tsmooth = !!smooth;\r\n\t\t\tconst prevRemaining: number = this._remaining;\r\n\t\t\tthis._curInitial = this._remaining = this._initial[this._initialIndex];\r\n\t\t\tif (smooth && prevRemaining < 0) {\r\n\t\t\t\tthis._remaining += prevRemaining; // Subtract how much we went over\r\n\t\t\t}\r\n\t\t\tthis._initialIndex = (this._initialIndex + 1) % this._initial.length;\r\n\t\t\tif (this._minDelta || this._maxDelta) {\r\n\t\t\t\t//\t\t\t\tthis._remaining += gtp.Utils.randomInt(this._minDelta, this._maxDelta);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttoString() {\r\n\t\t\treturn '[gtp.Delay: _initial=' + this._initial +\r\n\t\t\t\t', _remaining=' + this._remaining +\r\n\t\t\t\t', _loop=' + this._loop +\r\n\t\t\t\t', _callback=' + (this._callback != null) +\r\n\t\t\t\t']';\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"]}