{"version":3,"sources":["gtp/InputManager.ts"],"names":["gtp","gtp.InputManager","gtp.InputManager.constructor","gtp.InputManager.clearKeyState","gtp.InputManager.clearKeyStates","gtp.InputManager.ctrl","gtp.InputManager.down","gtp.InputManager.enter","gtp.InputManager.install","gtp.InputManager.isKeyDown","gtp.InputManager._keyDown","gtp.InputManager._keyUp","gtp.InputManager.left","gtp.InputManager.right","gtp.InputManager.shift","gtp.InputManager.up"],"mappings":"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","file":"gtp/InputManager.js","sourcesContent":["module gtp {\r\n\t'use strict';\r\n\r\n\texport class InputManager {\r\n\r\n\t\tprivate keys: boolean[];\r\n\t\tprivate _refireMillis: number;\r\n\t\tprivate _repeatTimers: { [key: number/*gtp.Keys*/]: any };\r\n\r\n\t\t/**\r\n\t\t * Handles input for games.<p>\r\n\t\t *\r\n\t\t * For keyboards, allows polling of individual key presses, both with and\r\n\t\t * without the keyboard repeat delay.<p>\r\n\t\t *\r\n\t\t * Touch and mouse input are currently not supported.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @param {int} [keyRefireMillis=0] What the key refiring time should be, in\r\n\t\t *        milliseconds.  A value of 0 means to take the operating system\r\n\t\t *        default.\r\n\t\t */\r\n\t\tconstructor(keyRefireMillis?: number) {\r\n\t\t\tthis.keys = [];\r\n\t\t\tthis._refireMillis = keyRefireMillis || 0;\r\n\t\t\tthis._repeatTimers = [];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets a specific key to its \"not depressed\" state.\r\n\t\t *\r\n\t\t * @param {int} key The key to reset.\r\n\t\t * @see clearKeyStates\r\n\t\t */\r\n\t\tclearKeyState(key: gtp.Keys) {\r\n\t\t\tthis.keys[key] = false;\r\n\t\t\tif (this._repeatTimers[key]) {\r\n\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets all keys to be in their \"not depressed\" states.\r\n\t\t */\r\n\t\tclearKeyStates() {\r\n\t\t\tfor (var i: number = 0; i < this.keys.length; i++) {\r\n\t\t\t\tthis.clearKeyState(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether ctrl is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tctrl(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_CTRL, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether down is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tdown(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_DOWN_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether enter is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tenter(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_ENTER, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Installs this keyboard manager.  Should be called during game\r\n\t\t * initialization.\r\n\t\t */\r\n\t\tinstall() {\r\n\t\t\tvar self: InputManager = this;\r\n\t\t\tdocument.onkeydown = function(e: KeyboardEvent) { self._keyDown(e); };\r\n\t\t\tdocument.onkeyup = function(e:  KeyboardEvent) { self._keyUp(e); };\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether a specific key is pressed.\r\n\t\t * @param keyCode {gtp.Keys} A key code.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tisKeyDown(keyCode: number, clear: boolean = false) {\r\n\t\t\tvar down: boolean = this.keys[keyCode];\r\n\t\t\tif (down && clear) {\r\n\t\t\t\tthis.keys[keyCode] = false;\r\n\t\t\t}\r\n\t\t\treturn down;\r\n\t\t}\r\n\r\n\t\t_keyDown(e: KeyboardEvent) {\r\n\t\t\tvar keyCode: number = e.keyCode;\r\n\t\t\tif (keyCode === 32 || (keyCode >= 37 && keyCode <= 40)) { // An arrow key or space\r\n\t\t\t\te.preventDefault();\r\n\t\t\t}\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (!this._repeatTimers[keyCode]) { // Only do on actual keydown, not key repeat\r\n\t\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t\t\tvar self: InputManager = this;\r\n\t\t\t\t\tthis._repeatTimers[keyCode] = setInterval(function() {\r\n\t\t\t\t\t\t//console.log('--- ' + new Date() + ': Setting keydown to true for: ' + keyCode + ', previous === ' + self.keys[keyCode]);\r\n\t\t\t\t\t\tself.keys[keyCode] = true;\r\n\t\t\t\t\t}, self._refireMillis);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t_keyUp(e: KeyboardEvent) {\r\n\t\t\tvar key: number = e.keyCode;\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (this._repeatTimers[key]) { // Should always be true\r\n\t\t\t\t\tthis.keys[key] = false;\r\n\t\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.error('_keyUp: Timer does not exist for key: ' + key + '!');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[key] = false;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether left is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tleft(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_LEFT_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether right is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tright(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_RIGHT_ARROW, clear);\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Returns whether shift is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tshift(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_SHIFT, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether up is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tup(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_UP_ARROW, clear);\r\n\t\t}\r\n\t}\r\n}\r\n"],"sourceRoot":"/source/"}