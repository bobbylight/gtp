{"version":3,"sources":["gtp/InputManager.ts"],"names":[],"mappings":"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","file":"gtp/InputManager.js","sourcesContent":["module gtp {\r\n\t'use strict';\r\n\r\n\texport class InputManager {\r\n\r\n\t\tprivate keys: boolean[];\r\n\t\tprivate _refireMillis: number;\r\n\t\tprivate _repeatTimers: { [key: number/*gtp.Keys*/]: any };\r\n\r\n\t\t/**\r\n\t\t * Handles input for games.<p>\r\n\t\t *\r\n\t\t * For keyboards, allows polling of individual key presses, both with and\r\n\t\t * without the keyboard repeat delay.<p>\r\n\t\t *\r\n\t\t * Touch and mouse input are currently not supported.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @param {int} [keyRefireMillis=0] What the key refiring time should be, in\r\n\t\t *        milliseconds.  A value of 0 means to take the operating system\r\n\t\t *        default.\r\n\t\t */\r\n\t\tconstructor(keyRefireMillis?: number) {\r\n\t\t\tthis.keys = [];\r\n\t\t\tthis._refireMillis = keyRefireMillis || 0;\r\n\t\t\tthis._repeatTimers = [];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets a specific key to its \"not depressed\" state.\r\n\t\t *\r\n\t\t * @param {int} key The key to reset.\r\n\t\t * @see clearKeyStates\r\n\t\t */\r\n\t\tclearKeyState(key: gtp.Keys) {\r\n\t\t\tthis.keys[key] = false;\r\n\t\t\tif (this._repeatTimers[key]) {\r\n\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets all keys to be in their \"not depressed\" states.\r\n\t\t */\r\n\t\tclearKeyStates() {\r\n\t\t\tfor (var i: number = 0; i < this.keys.length; i++) {\r\n\t\t\t\tthis.clearKeyState(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether ctrl is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tctrl(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_CTRL, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether down is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tdown(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_DOWN_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether enter is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tenter(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_ENTER, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Installs this keyboard manager.  Should be called during game\r\n\t\t * initialization.\r\n\t\t */\r\n\t\tinstall() {\r\n\t\t\tvar self: InputManager = this;\r\n\t\t\tdocument.onkeydown = function(e: KeyboardEvent) { self._keyDown(e); };\r\n\t\t\tdocument.onkeyup = function(e:  KeyboardEvent) { self._keyUp(e); };\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether a specific key is pressed.\r\n\t\t * @param keyCode {gtp.Keys} A key code.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tisKeyDown(keyCode: number, clear: boolean = false) {\r\n\t\t\tvar down: boolean = this.keys[keyCode];\r\n\t\t\tif (down && clear) {\r\n\t\t\t\tthis.keys[keyCode] = false;\r\n\t\t\t}\r\n\t\t\treturn down;\r\n\t\t}\r\n\r\n\t\t_keyDown(e: KeyboardEvent) {\r\n\t\t\tvar keyCode: number = e.keyCode;\r\n\t\t\tif (keyCode === 32 || (keyCode >= 37 && keyCode <= 40)) { // An arrow key or space\r\n\t\t\t\te.preventDefault();\r\n\t\t\t}\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (!this._repeatTimers[keyCode]) { // Only do on actual keydown, not key repeat\r\n\t\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t\t\tvar self: InputManager = this;\r\n\t\t\t\t\tthis._repeatTimers[keyCode] = setInterval(function() {\r\n\t\t\t\t\t\t//console.log('--- ' + new Date() + ': Setting keydown to true for: ' + keyCode + ', previous === ' + self.keys[keyCode]);\r\n\t\t\t\t\t\tself.keys[keyCode] = true;\r\n\t\t\t\t\t}, self._refireMillis);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t_keyUp(e: KeyboardEvent) {\r\n\t\t\tvar key: number = e.keyCode;\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (this._repeatTimers[key]) { // Should always be true\r\n\t\t\t\t\tthis.keys[key] = false;\r\n\t\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.error('_keyUp: Timer does not exist for key: ' + key + '!');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[key] = false;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether left is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tleft(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_LEFT_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether right is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tright(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_RIGHT_ARROW, clear);\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Returns whether shift is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tshift(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_SHIFT, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether up is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tup(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_UP_ARROW, clear);\r\n\t\t}\r\n\t}\r\n}\r\n"],"sourceRoot":"/source/"}