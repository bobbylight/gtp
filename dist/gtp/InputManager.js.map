{"version":3,"sources":["gtp/InputManager.ts"],"names":[],"mappings":"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","file":"gtp/InputManager.js","sourcesContent":["module gtp {\r\n\t'use strict';\r\n\r\n\texport class InputManager {\r\n\r\n\t\tprivate keys: boolean[];\r\n\t\tprivate _refireMillis: number;\r\n\t\tprivate _repeatTimers: { [key: number/*gtp.Keys*/]: any };\r\n\r\n\t\t/**\r\n\t\t * Handles input for games.<p>\r\n\t\t *\r\n\t\t * For keyboards, allows polling of individual key presses, both with and\r\n\t\t * without the keyboard repeat delay.<p>\r\n\t\t *\r\n\t\t * Touch and mouse input are currently not supported.\r\n\t\t *\r\n\t\t * @constructor\r\n\t\t * @param {int} [keyRefireMillis=0] What the key refiring time should be, in\r\n\t\t *        milliseconds.  A value of 0 means to take the operating system\r\n\t\t *        default.\r\n\t\t */\r\n\t\tconstructor(keyRefireMillis?: number) {\r\n\t\t\tthis.keys = [];\r\n\t\t\tthis._refireMillis = keyRefireMillis || 0;\r\n\t\t\tthis._repeatTimers = [];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets a specific key to its \"not depressed\" state.\r\n\t\t *\r\n\t\t * @param {int} key The key to reset.\r\n\t\t * @see clearKeyStates\r\n\t\t */\r\n\t\tclearKeyState(key: gtp.Keys) {\r\n\t\t\tthis.keys[key] = false;\r\n\t\t\tif (this._repeatTimers[key]) {\r\n\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Resets all keys to be in their \"not depressed\" states.\r\n\t\t */\r\n\t\tclearKeyStates() {\r\n\t\t\tfor (let i: number = 0; i < this.keys.length; i++) {\r\n\t\t\t\tthis.clearKeyState(i);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether ctrl is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tctrl(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_CTRL, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether down is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tdown(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_DOWN_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether enter is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tenter(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_ENTER, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Installs this keyboard manager.  Should be called during game\r\n\t\t * initialization.\r\n\t\t */\r\n\t\tinstall() {\r\n\t\t\tdocument.onkeydown = (e: KeyboardEvent) => { this._keyDown(e); };\r\n\t\t\tdocument.onkeyup = (e:  KeyboardEvent) => { this._keyUp(e); };\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether a specific key is pressed.\r\n\t\t * @param keyCode {gtp.Keys} A key code.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tisKeyDown(keyCode: number, clear: boolean = false) {\r\n\t\t\tconst down: boolean = this.keys[keyCode];\r\n\t\t\tif (down && clear) {\r\n\t\t\t\tthis.keys[keyCode] = false;\r\n\t\t\t}\r\n\t\t\treturn down;\r\n\t\t}\r\n\r\n\t\t_keyDown(e: KeyboardEvent) {\r\n\t\t\tconst keyCode: number = e.keyCode;\r\n\t\t\tif (keyCode === 32 || (keyCode >= 37 && keyCode <= 40)) { // An arrow key or space\r\n\t\t\t\te.preventDefault();\r\n\t\t\t}\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (!this._repeatTimers[keyCode]) { // Only do on actual keydown, not key repeat\r\n\t\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t\t\tthis._repeatTimers[keyCode] = setInterval(() => {\r\n\t\t\t\t\t\t//console.log('--- ' + new Date() + ': Setting keydown to true for: ' + keyCode + ', previous === ' + self.keys[keyCode]);\r\n\t\t\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t\t\t}, this._refireMillis);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[keyCode] = true;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t_keyUp(e: KeyboardEvent) {\r\n\t\t\tconst key: number = e.keyCode;\r\n\t\t\tif (this._refireMillis) {\r\n\t\t\t\tif (this._repeatTimers[key]) { // Should always be true\r\n\t\t\t\t\tthis.keys[key] = false;\r\n\t\t\t\t\tclearInterval(this._repeatTimers[key]);\r\n\t\t\t\t\tthis._repeatTimers[key] = null;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tconsole.error('_keyUp: Timer does not exist for key: ' + key + '!');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.keys[key] = false;\r\n\t\t\t}\r\n\t\t\te.stopPropagation();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether left is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tleft(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_LEFT_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether right is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tright(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_RIGHT_ARROW, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether shift is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tshift(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_SHIFT, clear);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns whether up is pressed.\r\n\t\t * @param clear {boolean} Whether the key's state should be reset to \"not\r\n\t\t *        pressed\" when this method returns.  This is useful to effectively\r\n\t\t *        enable the keyboard's buffering.\r\n\t\t * @return {boolean} Whether the key was pressed.\r\n\t\t */\r\n\t\tup(clear: boolean = false) {\r\n\t\t\treturn this.isKeyDown(gtp.Keys.KEY_UP_ARROW, clear);\r\n\t\t}\r\n\t}\r\n}\r\n"],"sourceRoot":"/source/"}